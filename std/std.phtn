include "macos.phtn"

macro NULL 0 end

macro true 0 0 == end
macro false 0 0 != end

// IO Buffers
macro stdin 0 end
macro stdout 1 end
macro stderr 2 end

// syscall wrappers
macro write SYS_WRITE syscall3 end
macro read SYS_READ syscall3 end
macro exit SYS_EXIT syscall1 drop end
macro open SYS_OPEN syscall2 end
macro close SYS_CLOSE syscall1 end
macro fstat64 SYS_FSTAT64 syscall2 end
macro mmap SYS_MMAP syscall6 end

// type sizes
macro sizeof(ptr) 8 end
macro sizeof(u64) 8 end

// struct stat of fstat64
macro sizeof(stat) 144 end
macro stat.st_dev 0 + end
macro stat.st_mode 4 + end
macro stat.st_nlink 6 + end
macro stat.st_ino 8 + end
macro stat.st_uid 16 + end
macro stat.st_gid 20 + end
macro stat.st_rdev 24 + end
macro stat.st_atimespec 32 + end
macro stat.st_mtimespec 48 + end
macro stat.st_ctimespec 64 + end
macro stat.st_size 96 + end
macro stat.st_blocks 104 + end
macro stat.st_blksize 112 + end
macro stat.st_flags 116 + end
macro stat.st_gen 120 + end
macro stat.st_lspare 124 + end
macro stat.st_qspare 128 + end
macro sizeof(st_dev) 4 end
macro sizeof(st_mode) 2 end
macro sizeof(st_nlink) 2 end
macro sizeof(st_ino) 8 end
macro sizeof(st_uid) 4 end
macro sizeof(st_gid) 4 end
macro sizeof(st_rdev) 4 end
macro sizeof(st_atimespec) 16 end
macro sizeof(st_mtimespec) 16 end
macro sizeof(st_ctimespec) 16 end
macro sizeof(st_size) 8 end
macro sizeof(st_blocks) 8 end
macro sizeof(st_blksize) 4 end
macro sizeof(st_flags) 4 end
macro sizeof(st_gen) 4 end
macro sizeof(st_lspare) 4 end
macro sizeof(st_qspare) 16 end


// mmap args
macro MAP_PRIVATE 2 end
macro PROT_READ 1 end


macro puts stdout write drop end
macro putsln puts "\n" puts end
macro eputs stderr write drop end
macro eputsln eputs "\n" eputs end

macro inc8
    dup @8 1 + swap !8
end

macro dec8
    dup @8 1 - swap !8
end

// struct Str {
//   length: uint64 (8 bytes)
//   data: char* (8 bytes)
// }

macro sizeof(Str) 16 end
macro Str.length 0 + end
macro Str.data 8 + end
macro !Str.length Str.length !8 end
macro !Str.data Str.data !8 end
macro @Str.length Str.length @8 end
macro @Str.data Str.data @8 ->ptr end

macro @Str // str: Str -> int ptr
    dup @Str.length swap @Str.data
end

macro !Str // n: int, s: ptr, str: Str -> None
    rot over
    !Str.length
    !Str.data
end

// Remove left most character from s
macro Str.chop() // s: Str -> None
    dup Str.length dec8
    Str.data inc8
end

macro Str.chop_line() // line: Str input: Str -> None
    dup2 Str.data @8 swap Str.data !8
    over Str.length 0 swap !8
    while
        if dup Str.length @8 0 > do
            dup Str.data @8 ->ptr @ '\n' !=
        else
            false
        end
    do
        dup Str.chop()
        over Str.length inc8
    end
    if dup Str.length @8 0 > do
        dup Str.chop()
    end
    drop2
end

macro Str.chop_word() // word: Str input: Str -> None
    dup2 Str.data @8 swap Str.data !8
    over Str.length 0 swap !8
    while
        if dup Str.length @8 0 > do
            dup Str.data @8 ->ptr @ ' ' !=
        else
            false
        end
    do
        dup Str.chop()
        over Str.length inc8
    end
    if dup Str.length @8 0 > do
        dup Str.chop()
    end
    drop2
end

macro Str.left_strip() // input: Str -> None
    while
        if dup Str.length @8 0 > do
            dup Str.data @8 ->ptr @ ' ' ==
        else
            false
        end
    do
        dup Str.chop()
    end drop
end

memory streq_a sizeof(Str) end
memory streq_b sizeof(Str) end
macro Str.equal() // n1: int, s1: ptr, n2: int, s2: ptr -> bool
    streq_a !Str
    streq_b !Str
    if streq_a @Str.length streq_b @Str.length == do
        0 while
            if dup streq_a @Str.length < do
                streq_a @Str.data @ streq_b @Str.data @ ==
            else
                false
            end
        do
            1 +
        end
        streq_a @Str.length ==
    else
        false
    end
end

memory parse_int_var sizeof(Str) end
macro Str.parse_int() // n: int, s: ptr -> int
    parse_int_var !Str
    0 0 while dup parse_int_var @Str.length < do
        dup parse_int_var @Str.data + @
        if dup isdigit not do
            report_error "Unknown word: " eputs word @Str eputsln
            1 exit
        end
        '0' - rot +
        swap
        1 +
    end drop
end

macro strlen
   dup
   while dup @ 0 != do 1 + end
   swap -
end

macro streq // str1: ptr str2: ptr -> bool
    while
        if over @ 0 != over @ 0 != and do
            dup2 @ swap @ ==
        else
            false
        end
    do
        1 + swap 1 +
    end
    @ 0 == swap @ 0 == and
end

macro argv[n]
    8 * argv + @8 ->ptr
end

macro not
    ->int bnot 1 and ->bool
end

macro isdigit
    '0' >=
    over '9' <=
    and
end

macro PUTD_BUFFER_CAP 32 end
memory putd_buffer PUTD_BUFFER_CAP end
// puts int into stdout
macro putd
  if dup 0 == do
    "0" puts
  else
    putd_buffer PUTD_BUFFER_CAP +
    while over 0 > do
      1 - dup rot
      10 dup2 / rot rot %
      rot swap '0' + swap ! swap
    end
    dup
    putd_buffer PUTD_BUFFER_CAP + swap - swap puts
  end
  drop
end

// puts int into stderr
macro eputd
  if dup 0 == do
    "0" puts
  else
    putd_buffer PUTD_BUFFER_CAP +
    while over 0 > do
      1 - dup rot
      10 dup2 / rot rot %
      rot swap '0' + swap ! swap
    end
    dup
    putd_buffer PUTD_BUFFER_CAP + swap - swap eputs
  end
  drop
end

macro dup2 over over end
macro drop2 drop drop end

macro % dup2 / * - end

// Deprecated

memory mem 640000 end