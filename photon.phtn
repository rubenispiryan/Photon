include "std.phtn"

macro compile_header
    ".section __TEXT, __text\n" puts
    ".global _start\n" puts
    ".align 3\n" puts
    ".macro push reg1:req\n" puts
    "   str \reg1, [sp, #-16]!\n" puts
    ".endmacro\n" puts
    ".macro pop reg1:req\n" puts
    "   ldr \reg1, [sp], #16\n" puts
    ".endmacro\n" puts
    ".macro pushw reg1\n" puts
    "   sub sp, sp, #16\n" puts
    "   stp \reg1, wzr, [sp]\n" puts
    ".endmacro\n" puts
    ".macro popw reg1\n" puts
    "   ldp \reg1, wzr, [sp]\n" puts
    "   add sp, sp, #16\n" puts
    ".endmacro\n" puts
    "print:\n" puts
    "   sub     sp, sp,  #48\n" puts
    "   stp     x29, x30, [sp,  #32]\n" puts
    "   add     x29, sp,  #32\n" puts
    "   mov     x10,  #-3689348814741910324\n" puts
    "   mov     x8, xzr\n" puts
    "   mov     w9,  #10\n" puts
    "   movk    x10,  #52429\n" puts
    "   mov     x11, sp\n" puts
    "   strb    w9, [sp,  #31]\n" puts
    ".LBB0_1:\n" puts
    "   umulh   x12, x0, x10\n" puts
    "   add     x14, x11, x8\n" puts
    "   sub     x8, x8,  #1\n" puts
    "   cmp     x0,  #9\n" puts
    "   lsr     x12, x12,  #3\n" puts
    "   msub    w13, w12, w9, w0\n" puts
    "   mov     x0, x12\n" puts
    "   orr     w13, w13,  #0x30\n" puts
    "   strb    w13, [x14,  #30]\n" puts
    "   b.hi    .LBB0_1\n" puts
    "   mov     x9, sp\n" puts
    "   mov     w10,  #1\n" puts
    "   add     x9, x9, x8\n" puts
    "   sub     x2, x10, x8\n" puts
    "   add     x1, x9,  #31\n" puts
    "   mov     x0,  #1\n" puts
    "   mov     x16,  #4\n" puts
    "   svc  #0\n" puts
    "   ldp     x29, x30, [sp,  #32]\n" puts
    "   add     sp, sp,  #48\n" puts
    "   ret\n" puts
end

macro compile_footer
    ".section __DATA, __data\n" puts
    "   argc: .quad 0\n" puts
    "   argv: .quad 0\n" puts
    ".section __DATA, __bss\n" puts
    "mem:\n" puts
    "   .skip " puts MEM_CAPACITY putd "\n" puts
end

// Memory layout
macro fd mem end
macro stat_buffer fd 8 + end // type: stat
macro content stat_buffer sizeof(stat) + end // type: Str
macro line content sizeof(Str) + end // type: Str
macro word line sizeof(Str) + end // type: Str
macro streq_a word sizeof(Str) + end // type: Str
macro streq_b streq_a sizeof(Str) + end // type: Str
macro parse_int_var streq_b sizeof(Str) + end // type: Str
macro putd_buffer parse_int_var sizeof(Str) + end
macro sim_stack_count putd_buffer PUTD_BUFFER_CAP + end
macro sim_stack sim_stack_count 8 + end
macro op_stack_count sim_stack SIM_STACK_CAP + end
macro op_stack op_stack_count 8 + end

// Constants
macro PUTD_BUFFER_CAP 32 end
macro SIM_STACK_CAP 1024 end
macro MEM_CAPACITY 640000 end

// Operation Enum
macro OP_PUSH_INT 0 end
macro OP_ADD      1 end
macro OP_PRINT    2 end
macro OP_SUB      3 end
macro OP_DUP      4 end
macro OP_DROP     5 end
macro OP_COUNT    6 end



macro sizeof(Op) 16 end
macro Op.type 0 end
macro Op.operand 8 end
macro !Op.type Op.type + !8 end
macro !Op.operand Op.operand + !8 end
macro @Op.type Op.type + @8 end
macro @Op.operand Op.operand + @8 end
macro !Op !Op.operand !Op.type end
macro @Op dup @Op.type swap @Op.operand end

// struct Op {
//   type: uint64 (8 bytes)
//   operand: uint64 (8 bytes)
// }

// expects: type:int operand:int
macro push_op
    op_stack_count @8 sizeof(Op) * op_stack +
    dup rot swap !Op
    op_stack_count inc8
end

macro putd
  if dup 0 == do
    "0" puts
  else
    putd_buffer PUTD_BUFFER_CAP +
    while over 0 > do
      1 - dup rot
      10 dup2 / rot rot %
      rot swap '0' + swap ! swap
    end
    dup
    putd_buffer PUTD_BUFFER_CAP + swap - swap puts
  end
  drop
end

// Requires streq_a, streq_b Str pointers in memory
macro Str.equal() // n1: int, s1: ptr, n2: int, s2: ptr -> bool
    streq_a !Str
    streq_b !Str
    if streq_a @Str.length streq_b @Str.length == do
        0 while
            if dup streq_a @Str.length < do
                streq_a @Str.data @ streq_b @Str.data @ ==
            else
                false
            end
        do
            1 +
        end
        streq_a @Str.length ==
    else
        false
    end
end

macro Str.parse_int() // n: int, s: ptr -> int
    parse_int_var !Str
    0 0 while dup parse_int_var @Str.length < do
        dup parse_int_var @Str.data + @ '0' - rot +
        swap
        1 +
    end drop
end

// Memory map file and save the pointer in content: Str
macro mmap_file
    if argc 3 < do
        print_usage
        "Filename is required\n" eputs
        1 exit
    end
    // open file given as first argument
    O_RDONLY 2 argv[n] open

    if dup -1 == do
        "Could not open file: " eputs 2 argv[n] dup strlen swap eputsln
        1 exit
    end

    fd !8

    stat_buffer fd @8 fstat64

    if dup -1 == do
        "Failed to call fstat on file: " eputs 2 argv[n] dup strlen swap eputsln
        1 exit
    end drop

    stat_buffer stat.st_size @8 content Str.length !8

    0                       // offset
    fd @8                   // fd
    MAP_PRIVATE             // flags
    PROT_READ               // prot
    content Str.length @8   // len
    NULL                    // addr
    mmap

    content Str.data !8

    if content Str.data @8 0 < do
      "Could not memory map file " eputs 2 argv[n] dup strlen swap eputs "\n" eputs
      1 exit
    end
end

// value
macro sim_stack_push
    if sim_stack_count @8 SIM_STACK_CAP >= do
        here eputs "[ERROR] data stack overflow in simulation mode" eputs 1 exit
    end
    sim_stack_count @8 8 * sim_stack + !8
    sim_stack_count inc8
end

macro sim_stack_pop
    if sim_stack_count @8 0 <= do
        here eputs "[ERROR] data stack underflow in simulation mode" eputs 1 exit
    end
    sim_stack_count dec8
    sim_stack_count @8 8 * sim_stack + @8
end

// TODO: Add drop3 Intrinsic
macro assert_op_count // here_len: int here_str: ptr expected_count: int
    if dup OP_COUNT != do
        drop
        eputs "Assertion Fail: Exhaustive handling of Op types" eputsln
        1 exit
    else drop2 drop end
end

macro simulate_program
    here 6 assert_op_count
    0 while dup op_stack_count @8 < do
        dup sizeof(Op) * op_stack +
        if dup @Op.type OP_PUSH_INT == do
            dup @Op.operand sim_stack_push
        elif dup @Op.type OP_ADD == do
            sim_stack_pop
            sim_stack_pop
            +
            sim_stack_push
        elif dup @Op.type OP_SUB == do
            sim_stack_pop
            sim_stack_pop
            swap
            -
            sim_stack_push
        elif dup @Op.type OP_PRINT == do
            sim_stack_pop
            print
        elif dup @Op.type OP_DROP == do
            sim_stack_pop
            drop
        elif dup @Op.type OP_DUP == do
            sim_stack_pop
            dup
            sim_stack_push
            sim_stack_push
        else "Unhandled Instruction\n" eputs 1 exit
        end drop
        1 +
    end drop
end

macro compile_program
    here 6 assert_op_count
    compile_header
    0 while dup op_stack_count @8 < do
        dup sizeof(Op) * op_stack +
        if dup @Op.type OP_PUSH_INT == do
            "   ;; -- push int " puts dup @Op.operand putd " --\n" puts
            "   ldr x0, =" puts dup @Op.operand putd "\n" puts
            "   push x0\n" puts
        elif dup @Op.type OP_ADD == do
            "   ;; -- add --\n" puts
            "   pop x0\n" puts
            "   pop x1\n" puts
            "   add x0, x0, x1\n" puts
            "   push x0\n" puts
        elif dup @Op.type OP_SUB == do
            "   ;; -- sub --\n" puts
            "   pop x0\n" puts
            "   pop x1\n" puts
            "   sub x0, x1, x0\n" puts
            "   push x0\n" puts
        elif dup @Op.type OP_PRINT == do
            "   ;; -- print --\n" puts
            "   pop x0\n" puts
            "   bl print\n" puts
        elif dup @Op.type OP_DROP == do
            "   ;; -- drop --\n" puts
            "   pop x0\n" puts
        elif dup @Op.type OP_DUP == do
            "   ;; -- dup --\n" puts
            "   pop x0\n" puts
            "   push x0\n" puts
            "   push x0\n" puts
        else "Unhandled Instruction\n" eputs 1 exit
        end drop
        1 +
    end drop
    compile_footer
end

macro print_ops
    0 while dup op_stack_count @8 < do
        dup sizeof(Op) * op_stack +
        "Type: " puts dup @Op.type putd
        ", Operand: " puts @Op.operand print
        1 +
    end drop
end

// Expects file contents to be in content: Str
// Expects that line, word are allocated
macro parse_file_as_op
    here 6 assert_op_count
    while content Str.length @8 0 > do
    line content Str.chop_line()
        while line Str.length @8 0 > do
            line Str.left_strip()
            word line Str.chop_word()
            if word @Str "+" Str.equal() do
                OP_ADD 0 push_op
            elif word @Str "-" Str.equal() do
                OP_SUB 0 push_op
            elif word @Str "print" Str.equal() do
                OP_PRINT 0 push_op
            elif word @Str "dup" Str.equal() do
                OP_DUP 0 push_op
            elif word @Str "drop" Str.equal() do
                OP_DROP 0 push_op
            else
                OP_PUSH_INT word @Str Str.parse_int() push_op
            end
        end
    end
end

macro print_usage
    "Usage: photon.py <SUBCOMMAND>\n" puts
    "Subcommands:\n" puts
    "     sim <FILENAME>     Simulate the program in a macos little endian environment\n" puts
    "     com <FILENAME>     Compile the program to arm 64-bit assembly\n" puts
end

macro main
    if argc 2 < do
        print_usage
    else
        mmap_file
        parse_file_as_op
        1 argv[n]
        if dup "sim\0" streq do
            simulate_program
        elif dup "com\0" streq do
            compile_program
        elif dup "dump\0" streq do
            print_ops
        else "Invalid Subcommand\n" eputs print_usage 1 exit
        end
        drop
    end
end

main