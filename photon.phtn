include "std.phtn"

macro compile_header
    ".section __TEXT, __text\n" puts
    ".global _start\n" puts
    ".align 3\n" puts
    ".macro push reg1:req\n" puts
    "   str \reg1, [sp, #-16]!\n" puts
    ".endmacro\n" puts
    ".macro pop reg1:req\n" puts
    "   ldr \reg1, [sp], #16\n" puts
    ".endmacro\n" puts
    ".macro pushw reg1\n" puts
    "   sub sp, sp, #16\n" puts
    "   stp \reg1, wzr, [sp]\n" puts
    ".endmacro\n" puts
    ".macro popw reg1\n" puts
    "   ldp \reg1, wzr, [sp]\n" puts
    "   add sp, sp, #16\n" puts
    ".endmacro\n" puts
    "print:\n" puts
    "   sub     sp, sp,  #48\n" puts
    "   stp     x29, x30, [sp,  #32]\n" puts
    "   add     x29, sp,  #32\n" puts
    "   mov     x10,  #-3689348814741910324\n" puts
    "   mov     x8, xzr\n" puts
    "   mov     w9,  #10\n" puts
    "   movk    x10,  #52429\n" puts
    "   mov     x11, sp\n" puts
    "   strb    w9, [sp,  #31]\n" puts
    ".LBB0_1:\n" puts
    "   umulh   x12, x0, x10\n" puts
    "   add     x14, x11, x8\n" puts
    "   sub     x8, x8,  #1\n" puts
    "   cmp     x0,  #9\n" puts
    "   lsr     x12, x12,  #3\n" puts
    "   msub    w13, w12, w9, w0\n" puts
    "   mov     x0, x12\n" puts
    "   orr     w13, w13,  #0x30\n" puts
    "   strb    w13, [x14,  #30]\n" puts
    "   b.hi    .LBB0_1\n" puts
    "   mov     x9, sp\n" puts
    "   mov     w10,  #1\n" puts
    "   add     x9, x9, x8\n" puts
    "   sub     x2, x10, x8\n" puts
    "   add     x1, x9,  #31\n" puts
    "   mov     x0,  #1\n" puts
    "   mov     x16,  #4\n" puts
    "   svc  #0\n" puts
    "   ldp     x29, x30, [sp,  #32]\n" puts
    "   add     sp, sp,  #48\n" puts
    "   ret\n" puts
end

macro compile_footer
    ".section __DATA, __data\n" puts
    "   argc: .quad 0\n" puts
    "   argv: .quad 0\n" puts
    ".section __DATA, __bss\n" puts
    "mem:\n" puts
    "   .skip " puts MEM_CAPACITY putd "\n" puts
end

// Constants
macro PUTD_BUFFER_CAP 32 end
macro SIM_STACK_CAP 1024 end
macro MEM_CAPACITY 640000 end

// Operation Enum
macro OP_PUSH_INT 0 end
macro OP_ADD      1 end
macro OP_PRINT    2 end

// Memory layout
macro putd_buffer mem end
macro sim_stack_count putd_buffer PUTD_BUFFER_CAP + end
macro sim_stack sim_stack_count 8 + end
macro op_stack_count sim_stack SIM_STACK_CAP + end
macro op_stack op_stack_count 8 + end

macro sizeof(Op) 16 end

// struct Op {
//   type: uint64 (8 bytes)
//   operand: uint64 (8 bytes)
// }

// expects: type:int operand:int
macro push_op
    op_stack_count ,8 sizeof(Op) * op_stack +
    dup 8 + rot .8
    swap .8
    op_stack_count inc64
end

macro print_ops
    0 while dup op_stack_count ,8 < do
        dup sizeof(Op) * op_stack +
        dup ,8 "Type: " puts putd
        8 + ,8 ", Operand: " puts print
        1 +
    end drop
end

macro putd
  if dup 0 == do
    "0" puts
  else
    putd_buffer PUTD_BUFFER_CAP +
    while over 0 > do
      1 - dup rot
      10 dup2 / rot rot %
      rot swap '0' + . swap
    end
    dup
    putd_buffer PUTD_BUFFER_CAP + swap - swap puts
  end
  drop
end

// value
macro sim_stack_push
    if sim_stack_count ,8 SIM_STACK_CAP >= do
        here eputs "[ERROR] data stack overflow in simulation mode" eputs 1 exit
    end
    sim_stack_count ,8 8 * sim_stack + swap .8
    sim_stack_count inc64
end

macro sim_stack_pop
    if sim_stack_count ,8 0 <= do
        here eputs "[ERROR] data stack underflow in simulation mode" eputs 1 exit
    end
    sim_stack_count dec64
    sim_stack_count ,8 8 * sim_stack + ,8
end

macro simulate_program
    0 while dup op_stack_count ,8 < do
        dup sizeof(Op) * op_stack +
        if dup ,8 OP_PUSH_INT == do
            dup 8 + ,8 sim_stack_push
        elif dup ,8 OP_ADD == do
            sim_stack_pop
            sim_stack_pop
            +
            sim_stack_push
        elif dup ,8 OP_PRINT == do
            sim_stack_pop
            print
        else "Unhandled Instruction\n" eputs 1 exit
        end drop
        1 +
    end drop
end

macro compile_program
    compile_header
    0 while dup op_stack_count ,8 < do
        dup sizeof(Op) * op_stack +
        if dup ,8 OP_PUSH_INT == do
            "   ;; -- push int " puts dup 8 + ,8 putd " --\n" puts
            "   ldr x0, =" puts dup 8 + ,8 putd "\n" puts
            "   push x0\n" puts
        elif dup ,8 OP_ADD == do
            "   ;; -- add --\n" puts
            "   pop x0\n" puts
            "   pop x1\n" puts
            "   add x0, x0, x1\n" puts
            "   push x0\n" puts
        elif dup ,8 OP_PRINT == do
            "   ;; -- print --\n" puts
            "   pop x0\n" puts
            "   bl print\n" puts
        else "Unhandled Instruction\n" eputs 1 exit
        end drop
        1 +
    end drop
    compile_footer
end

macro program
    OP_PUSH_INT 4 push_op
    OP_PUSH_INT 5 push_op
    OP_ADD      0 push_op
    OP_PRINT    0 push_op
end

macro print_usage
    "Usage: photon.py <SUBCOMMAND>\n" puts
    "Subcommands:\n" puts
    "     sim     Simulate the program in a macos little endian environment\n" puts
    "     com     Compile the program to arm 64-bit assembly\n" puts
end

macro main
    if argc 2 < do
        print_usage
    else
        program
        1 argv[n]
        if dup "sim\0" streq do
            simulate_program
        elif dup "com\0" streq do
            compile_program
        else "Invalid Subcommand\n" eputs print_usage 1 exit
        end
        drop
    end
end

main