include "std.phtn"

// Constants
macro SIM_STACK_CAP 1024 end
macro OP_STACK_CAP 1024 end
macro MEM_CAPACITY 640000 end

proc compile_header
    ".section __TEXT, __text\n" puts
    ".global _start\n" puts
    ".align 3\n" puts
    ".macro push reg1:req\n" puts
    "   str \reg1, [sp, #-16]!\n" puts
    ".endmacro\n" puts
    ".macro pop reg1:req\n" puts
    "   ldr \reg1, [sp], #16\n" puts
    ".endmacro\n" puts
    ".macro pushw reg1\n" puts
    "   sub sp, sp, #16\n" puts
    "   stp \reg1, wzr, [sp]\n" puts
    ".endmacro\n" puts
    ".macro popw reg1\n" puts
    "   ldp \reg1, wzr, [sp]\n" puts
    "   add sp, sp, #16\n" puts
    ".endmacro\n" puts
    "print:\n" puts
    "   sub     sp, sp,  #48\n" puts
    "   stp     x29, x30, [sp,  #32]\n" puts
    "   add     x29, sp,  #32\n" puts
    "   mov     x10,  #-3689348814741910324\n" puts
    "   mov     x8, xzr\n" puts
    "   mov     w9,  #10\n" puts
    "   movk    x10,  #52429\n" puts
    "   mov     x11, sp\n" puts
    "   strb    w9, [sp,  #31]\n" puts
    ".LBB0_1:\n" puts
    "   umulh   x12, x0, x10\n" puts
    "   add     x14, x11, x8\n" puts
    "   sub     x8, x8,  #1\n" puts
    "   cmp     x0,  #9\n" puts
    "   lsr     x12, x12,  #3\n" puts
    "   msub    w13, w12, w9, w0\n" puts
    "   mov     x0, x12\n" puts
    "   orr     w13, w13,  #0x30\n" puts
    "   strb    w13, [x14,  #30]\n" puts
    "   b.hi    .LBB0_1\n" puts
    "   mov     x9, sp\n" puts
    "   mov     w10,  #1\n" puts
    "   add     x9, x9, x8\n" puts
    "   sub     x2, x10, x8\n" puts
    "   add     x1, x9,  #31\n" puts
    "   mov     x0,  #1\n" puts
    "   mov     x16,  #4\n" puts
    "   svc  #0\n" puts
    "   ldp     x29, x30, [sp,  #32]\n" puts
    "   add     sp, sp,  #48\n" puts
    "   ret\n" puts
end

proc compile_footer
    ".section __DATA, __data\n" puts
    "   argc: .quad 0\n" puts
    "   argv: .quad 0\n" puts
    ".section __DATA, __bss\n" puts
    "mem:\n" puts
    "   .skip " puts MEM_CAPACITY putd "\n" puts
end

// Operation Enum
macro OP_PUSH_INT 0 end
macro OP_ADD      1 end
macro OP_PRINT    2 end
macro OP_SUB      3 end
macro OP_MUL      4 end
macro OP_DUP      5 end
macro OP_DROP     6 end
macro OP_COUNT    7 end


// struct Loc {
//   filename: ptr    (8 bytes)
//   line_num: uint64 (8 bytes)
//   col_num:  uint64 (8 bytes)
// }

macro sizeof(Loc) 24 end
macro Loc.filename 0 end
macro Loc.line_num 8 end
macro Loc.col_num 16 end
proc @Loc.filename Loc.filename + @8 end
proc @Loc.line_num Loc.line_num + @8 end
proc @Loc.col_num Loc.col_num + @8 end
proc @Loc
    dup @Loc.filename swap
    dup @Loc.line_num swap
    @Loc.col_num
end
proc !Loc.filename Loc.filename + !8 end
proc !Loc.line_num Loc.line_num + !8 end
proc !Loc.col_num Loc.col_num + !8 end

// struct Op {
//   type:    uint64 (8 bytes)
//   operand: uint64 (8 bytes)
// }

macro sizeof(Op) 16 end
macro Op.type 0 end
macro Op.operand 8 end
proc !Op.type Op.type + !8 end
proc !Op.operand Op.operand + !8 end
proc @Op.type Op.type + @8 end
proc @Op.operand Op.operand + @8 end
proc !Op !Op.operand !Op.type end
proc @Op dup @Op.type swap @Op.operand end

// Memory layout
memory fd sizeof(ptr) end
memory loc sizeof(Loc) end
memory stat_buffer sizeof(stat) end
memory content sizeof(Str) end
memory line sizeof(Str) end
memory word sizeof(Str) end
memory sim_stack_count sizeof(u64) end
memory sim_stack sizeof(u64) SIM_STACK_CAP * end
memory op_stack_count sizeof(u64) end
memory op_stack sizeof(Op) OP_STACK_CAP * end

// expects: type:int operand:int
proc push_op
    op_stack_count @8 sizeof(Op) * op_stack +
    dup rot swap !Op
    op_stack_count inc8
end

proc Loc.puts() // loc: Loc -> None
    @Loc
    rot dup ->ptr strlen swap puts ":" puts
    "[" puts
    swap 1 + putd ":" puts
    putd
    "] " puts
end

proc Loc.eputs() // loc: Loc -> None
    @Loc
    rot dup ->ptr strlen swap eputs ":" eputs
    "[" eputs
    swap 1 + eputd ":" eputs
    putd
    "] " eputs
end


proc report_error // n: int, s: ptr -> None
    loc Loc.eputs()
    "[ERROR] " eputs
end

proc print_usage
    "Usage: photon.py <SUBCOMMAND>\n" puts
    "Subcommands:\n" puts
    "     sim <FILENAME>     Simulate the program in a macos little endian environment\n" puts
    "     com <FILENAME>     Compile the program to arm 64-bit assembly\n" puts
end

// Memory map file and save the pointer in content: Str
proc mmap_file
    if argc 3 < do
        print_usage
        "Filename is required\n" eputs
        1 exit
    end
    // open file given as first argument
    O_RDONLY 2 argv[n] open

    if dup -1 == do
        "Could not open file: " eputs 2 argv[n] dup strlen swap eputsln
        1 exit
    end

    fd !8

    stat_buffer fd @8 fstat64

    if dup -1 == do
        "Failed to call fstat on file: " eputs 2 argv[n] dup strlen swap eputsln
        1 exit
    end drop

    stat_buffer stat.st_size @8 content Str.length !8

    0                       // offset
    fd @8                   // fd
    MAP_PRIVATE             // flags
    PROT_READ               // prot
    content Str.length @8   // len
    NULL                    // addr
    mmap

    content Str.data !8

    if content Str.data @8 0 < do
      "Could not memory map file " eputs 2 argv[n] dup strlen swap eputs "\n" eputs
      1 exit
    end
end

// value
proc sim_stack_push
    if sim_stack_count @8 SIM_STACK_CAP >= do
        here eputs "[ERROR] data stack overflow in simulation mode" eputs 1 exit
    end
    sim_stack_count @8 8 * sim_stack + !8
    sim_stack_count inc8
end

proc sim_stack_pop
    if sim_stack_count @8 0 <= do
        here eputs "[ERROR] data stack underflow in simulation mode" eputs 1 exit
    end
    sim_stack_count dec8
    sim_stack_count @8 8 * sim_stack + @8
end

// TODO: Add drop3 Intrinsic
proc assert_op_count // here_len: int here_str: ptr expected_count: int
    if dup OP_COUNT != do
        drop
        eputs "Assertion Fail: Exhaustive handling of Op types" eputsln
        1 exit
    else drop2 drop end
end

proc simulate_program
    here 7 assert_op_count
    0 while dup op_stack_count @8 < do
        dup sizeof(Op) * op_stack +
        if dup @Op.type OP_PUSH_INT == do
            dup @Op.operand sim_stack_push
        elif dup @Op.type OP_ADD == do
            sim_stack_pop
            sim_stack_pop
            +
            sim_stack_push
        elif dup @Op.type OP_SUB == do
            sim_stack_pop
            sim_stack_pop
            swap
            -
            sim_stack_push
        elif dup @Op.type OP_MUL == do
            sim_stack_pop
            sim_stack_pop
            *
            sim_stack_push
        elif dup @Op.type OP_PRINT == do
            sim_stack_pop
            print
        elif dup @Op.type OP_DROP == do
            sim_stack_pop
            drop
        elif dup @Op.type OP_DUP == do
            sim_stack_pop
            dup
            sim_stack_push
            sim_stack_push
        else "Unhandled Instruction: " eputs dup @Op.type eputd "\n" eputs 1 exit
        end drop
        1 +
    end drop
end

proc compile_program
    here 7 assert_op_count
    compile_header
    "   ;; -- start --\n" puts
    0 while dup op_stack_count @8 < do
        dup sizeof(Op) * op_stack +
        if dup @Op.type OP_PUSH_INT == do
            "   ;; -- push int " puts dup @Op.operand putd " --\n" puts
            "   ldr x0, =" puts dup @Op.operand putd "\n" puts
            "   push x0\n" puts
        elif dup @Op.type OP_ADD == do
            "   ;; -- add --\n" puts
            "   pop x0\n" puts
            "   pop x1\n" puts
            "   add x0, x0, x1\n" puts
            "   push x0\n" puts
        elif dup @Op.type OP_SUB == do
            "   ;; -- sub --\n" puts
            "   pop x0\n" puts
            "   pop x1\n" puts
            "   sub x0, x1, x0\n" puts
            "   push x0\n" puts
        elif dup @Op.type OP_MUL == do
            "   ;; -- mul --\n" puts
            "   pop x0\n" puts
            "   pop x1\n" puts
            "   mul x0, x0, x1\n" puts
            "   push x0\n" puts
        elif dup @Op.type OP_PRINT == do
            "   ;; -- print --\n" puts
            "   pop x0\n" puts
            "   bl print\n" puts
        elif dup @Op.type OP_DROP == do
            "   ;; -- drop --\n" puts
            "   pop x0\n" puts
        elif dup @Op.type OP_DUP == do
            "   ;; -- dup --\n" puts
            "   pop x0\n" puts
            "   push x0\n" puts
            "   push x0\n" puts
        else "Unhandled Instruction: " eputs dup @Op.type eputd "\n" eputs  1 exit
        end drop
        1 +
    end drop
    compile_footer
end

proc print_ops
    0 while dup op_stack_count @8 < do
        dup sizeof(Op) * op_stack +
        "Type: " puts dup @Op.type putd
        ", Operand: " puts @Op.operand print
        1 +
    end drop
end

// Expects file contents to be in content: Str
// Expects that line, word are allocated
proc parse_file_as_op
    here 7 assert_op_count
    2 argv[n] loc !Loc.filename
    0 while content Str.length @8 0 > do
        dup loc !Loc.line_num
        line content Str.chop_line()
        0 while line Str.length @8 0 > do
            dup loc !Loc.col_num
            line Str.left_strip()
            word line Str.chop_word()
            if word @Str "+" Str.equal() do
                OP_ADD 0 push_op
            elif word @Str "-" Str.equal() do
                OP_SUB 0 push_op
            elif word @Str "*" Str.equal() do
                OP_MUL 0 push_op
            elif word @Str "print" Str.equal() do
                OP_PRINT 0 push_op
            elif word @Str "dup" Str.equal() do
                OP_DUP 0 push_op
            elif word @Str "drop" Str.equal() do
                OP_DROP 0 push_op
            else
                OP_PUSH_INT word @Str Str.parse_int() push_op
            end
            1 +
        end drop
        1 +
    end drop
end

proc main
    if argc 2 < do
        print_usage
    else
        mmap_file
        parse_file_as_op
        1 argv[n]
        if dup "sim\0" streq do
            simulate_program
        elif dup "com\0" streq do
            compile_program
        elif dup "dump\0" streq do
            print_ops
        else "Invalid Subcommand\n" eputs print_usage 1 exit
        end
        drop
    end
end

main